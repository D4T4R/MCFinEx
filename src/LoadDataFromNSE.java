/**
 * This code is only for education purpose only. No financial transactions should be made based on the data generated by this code.
 */

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Locale;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import com.utils.DBUtils;

public class LoadDataFromNSE {

	private static String sURL = "https://archives.nseindia.com/content/historical/EQUITIES/2022/MAY/cm{lastWorkingDay}bhav.csv.zip";
	private static String sDestinationFolder = "E:\\selenium\\selenium";

	public static void main(String[] args) throws Exception {
		String strBhavCopy = downloadFileHttp();
		// TODO Auto-generated method stub
		if (null != strBhavCopy) {
			LoadDataFromNSE objLoadDataFromNSE = new LoadDataFromNSE();
			objLoadDataFromNSE.readBhavCopy(strBhavCopy);
		}
	}

	private void readBhavCopy(String sBhavCopyLocation) throws Exception {
		String sBhavCopyEntry = null;
		String[] sBhavCopyFields = null;
		DBUtils objDBUtils = new DBUtils();
		HashMap<String, String> hmStockFinancials = new HashMap<String, String>();
		HashMap<String, String> hmStockMaster = new HashMap<String, String>();

		BufferedReader fBhavCopy = new BufferedReader(new FileReader(sBhavCopyLocation));
		sBhavCopyEntry = fBhavCopy.readLine(); // skip header
		sBhavCopyEntry = fBhavCopy.readLine();
		while (sBhavCopyEntry != null && !sBhavCopyEntry.isEmpty()) {
			sBhavCopyFields = sBhavCopyEntry.split(",");
			hmStockFinancials.put("TABLE", "stock_financials");
			hmStockFinancials.put("COMPANYCODE", sBhavCopyFields[0]);
			hmStockFinancials.put("CURRENT_PRICE", sBhavCopyFields[5]);

			hmStockMaster.put("TABLE", "STOCK_MASTER");
			hmStockMaster.put("COMPANYCODE", sBhavCopyFields[0]);
			hmStockMaster.put("ISIN_CODE", sBhavCopyFields[12]);

			if ("EQ".equalsIgnoreCase(sBhavCopyFields[1]) || "BE".equalsIgnoreCase(sBhavCopyFields[1])) {
				objDBUtils.setData(hmStockMaster);
				objDBUtils.setData(hmStockFinancials);
			}
			hmStockMaster.clear();
			hmStockFinancials.clear();

			sBhavCopyEntry = fBhavCopy.readLine();
		}

		fBhavCopy.close();

	}

	private static String downloadFileHttp() throws Exception {

		try {
			long lDays = 0L;
			boolean bGotFile = false;
			String sDate = null;

			while (!bGotFile) {
				sDate = DateTimeFormatter.ofPattern("ddMMMyyyy", Locale.ENGLISH)
						.format(LocalDate.now().minusDays(lDays)).toUpperCase();
				System.out.println(sDate);
				String sURL1 = sURL.replace("{lastWorkingDay}", sDate);

				URL oracle = new URL(sURL1);
				HttpURLConnection connection = (HttpURLConnection) oracle.openConnection();

				// Set timeouts 2000 in milliseconds and throw exception
				connection.setConnectTimeout(2000);
				connection.setReadTimeout(2000);

				try {
					connection.getHeaderFields();
					InputStream in = connection.getInputStream();
					FileOutputStream out = new FileOutputStream(
							sDestinationFolder + "\\bhavcopy\\bhavcopy" + sDate + ".zip");
					copySource2Dest(in, out, 1024);
					out.close();

					if (in != null) {
						bGotFile = true;
					}
				} catch (SocketTimeoutException ste) {
					sDate = null;
					ste.getMessage();
				}

				lDays++;
			}

			String strBhavCopyFileName = extractFolder(sDestinationFolder + "\\bhavcopy\\bhavcopy" + sDate + ".zip",
					sDestinationFolder);

			// Path path = FileSystems.getDefault().getPath(destination, "bhavcopy.zip");
			// boolean succ = Files.deleteIfExists(path);

			System.out.println("Download is successfull");
			return strBhavCopyFileName;
		} catch (Exception e) {
			System.out.println("Error in downloading : " + e);
			return null;
		}
	}

	public static void copySource2Dest(InputStream input, OutputStream output, int bufferSize) throws IOException {
		byte[] buf = new byte[bufferSize];
		int n = input.read(buf);
		while (n >= 0) {
			output.write(buf, 0, n);
			n = input.read(buf);
		}
		output.flush();
	}

	public static String extractFolder(String zipFile, String extractFolder) {
		String strFileName = null;
		try {
			int BUFFER = 2048;
			File file = new File(zipFile);

			ZipFile zip = new ZipFile(file);
			String newPath = extractFolder;

			new File(newPath).mkdir();
			Enumeration zipFileEntries = zip.entries();

			ZipEntry entry;

			// Process each entry
			while (zipFileEntries.hasMoreElements()) {
				// grab a zip file entry
				entry = (ZipEntry) zipFileEntries.nextElement();
				String currentEntry = entry.getName();

				File destFile = new File(newPath, currentEntry);
				File destinationParent = destFile.getParentFile();
				System.out.println(destFile.getName() + " PAth " + destFile.getPath());
				strFileName = destFile.getPath();
				// create the parent directory structure if needed
				destinationParent.mkdirs();

				if (!entry.isDirectory()) {
					BufferedInputStream is = new BufferedInputStream(zip.getInputStream(entry));
					int currentByte;
					// establish buffer for writing file
					byte data[] = new byte[BUFFER];

					// write the current file to disk
					FileOutputStream fos = new FileOutputStream(destFile);
					BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);

					// read and write until last byte is encountered
					while ((currentByte = is.read(data, 0, BUFFER)) != -1) {
						dest.write(data, 0, currentByte);
					}
					dest.flush();
					dest.close();
					is.close();
				}
			}
			zip.close();
		} catch (Exception e) {
			System.out.println("ERROR: " + e.getMessage());
		}
		return strFileName;
	}

}
